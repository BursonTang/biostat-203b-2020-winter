---
title: "Biostat 203B Homework 4"
author: Burson Tang UID#305068045
subtitle: Due Mar 20 @ 11:59PM
output:
  # ioslides_presentation: default
  html_document:
    toc: true
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Task

In this assignment, you are to write a report analyzing the electronic health record (EHR) data MIMIC-III. You report will demostrate your knowledge of working with PostgreSQL database, data visualization, and commonly used analytical methods such as logistic regression and neural network. Your report should include at least following parts:  

1. An informative title. For example, _30-Day Mortality Rate of Myocardia Infarction Patients Admitted to CCU_.  

2. Introduction. Describe the MIMIC-III data set and what research hypothesis/goal you are to address using this data.

3. Data preparation. Create a study cohort from MIMIC-III corresponding to your research hypothesis/goal. See the examplary code below. Use a CONSORT flow diagram to summarize your steps to create the cohort.

4. Data visualization. Use visualization to summarize the cohort you created. 

5. Analytics. Use at least two analytical approaches to address your research hypothesis/goal. For example, we can use (1) logistic regression and (2) neural network to build a predictive model for the 30-day mortality rate of patients admitted into CCU and compare their predictive performance. Summarize your results in graphs.

6. Conclusions. 

# Learning resources about analyzing EHR data

- _Secondary Analysis of Electronic Health Records_: <https://link.springer.com/book/10.1007/978-3-319-43742-2> 

- _The Book of OHDSI_: <https://ohdsi.github.io/TheBookOfOhdsi/>. 

- The GitHub repository <https://github.com/MIT-LCP/mimic-code> contains some code examples for working with the MIMIC-III data. Following sample code derives from <https://github.com/MIT-LCP/mimic-code/blob/master/tutorials/dplyr-frontend/intro.md>. 


*Report starts here*

# Title: Mortality Rate of Influenza Patients Admitted to the Hospital
<!-- or maybe influenza? -->
## 1. Introduction

## 2. Data Preparation

Load database libraries and the tidyverse frontend:
```{r}
library(DBI)
library(RPostgreSQL)
library(tidyverse)
library(lubridate)
```

Connect to PostgresSQL datanase: Credentials for using PostgreSQL database. We are going to use username `postgres` with password `postgres` to access the `mimic` database in the schemee `mimiciii`. 
```{r}
# Load configuration settings
dbdriver <- 'PostgreSQL'
#host  <- '127.0.0.1'
#port  <- '5432'
user  <- 'postgres'
password <- 'postgres'
dbname <- 'mimic'
schema <- 'mimiciii'
# Connect to the database using the configuration settings
con <- dbConnect(RPostgreSQL::PostgreSQL(), 
                 dbname = dbname, 
                 #host = host, 
                 #port = port, 
                 user = user, 
                 password = password)
# Set the default schema
dbExecute(con, paste("SET search_path TO ", schema, sep=" "))
con

# List tables in the `mimic` database:
dbListTables(con)
```


The table `d_icd_diagnoses` stores all types of diagnosis and corresponding codes, from which the influenza-related diagnosis are extracted.
```{r}
# Connect to the admissions table
Admissions <- tbl(con, "admissions")
Admissions %>% print(width = Inf)
# Pneu <- Admission %>% filter(str_detect(tolower(DIAGNOSIS), "PNEUMONIA"))

tbl(con, "d_icd_diagnoses")%>% summarize(n())

# Find all diagnoses code for influenza
tbl(con, "d_icd_diagnoses") %>%
  filter(str_detect(long_title, "influenza")) %>% print(width = Inf) ->
  flu_codes
```

`diagnoses_icd` table stores the diagnosis of each admission. We use semi_join() to keep the rows in `diagnoses_icd` that match the codes related to influenza:
```{r}
# get all the admission because of flue via semi_join
tbl(con, "diagnoses_icd") %>%
  semi_join(flu_codes, by = "icd9_code") %>%
  print() -> flu_adm
```

According to the documentation for the `patients` table, patients can have different diagnosis, and thus influenza may not be listed as the principal diagnosis. In order to focus on patients for whom influenza was central to their hospitalization, we will include records with influenza in any of the first five diagnosis positions according to the `seq_num` field. To avoid duplicate admissions, only the first influenza diagnosis for each admission is used in the analysis. At the end, a logical variable indicating the influenza is the principal diagonosis or not (the influenza is regarded as the principal diagnosis only if records have `seq_num` equal to one).
```{r}
# Use filter to only include records with flu in top five diagnosis positions
flu_adm %>%
  filter(seq_num <= 5) %>%
  group_by(subject_id, hadm_id) %>%
  # top_n(1, wt = seq_num) %>% #  not working. bug? use following as workaround
  filter(min_rank(seq_num) <= 1) %>%
  ungroup() %>%
  select(subject_id, hadm_id, icd9_code, seq_num) %>%
  # check if the flu is the principal diagnosis
  mutate(principal_dx = (seq_num == 1)) %>%
  select(-seq_num) %>%
  print() -> flu_adm
```

`inner_join` the table of admission `admissions` with the table of influenza-caused admission to pull the admitting and discharge time and other necessary information. Also join the `patients` table to get more detailed demographic information of the patients admitted into hospital. 

Here the `hospital_expire_flag` and `expire_flag` are logical variables indicating whether the patient died (1) or not (0). Create more intelligible variable names for them.

```{r}
select(tbl(con, "admissions"), 
       subject_id, hadm_id, admittime, dischtime, hospital_expire_flag, ethnicity)%>%
  inner_join(flu_adm, by = c("subject_id", "hadm_id")) %>%
  left_join(
    select(tbl(con, "patients"), -row_id, -dod_hosp, -dod_ssn),
    by = "subject_id") %>%
  mutate(mortality_in_hospital = hospital_expire_flag==1,
         mortality_general = expire_flag==1) %>%
  select(-hospital_expire_flag, -expire_flag) %>%
  print() -> flu_admissions
```

Calculate the age for all patients in the table. According to the documentation for the patients table, the patients of 90 years and older had their ages artficially inflated, and thus removed from the table. Some important variables are moved to the front.

*Note* Many mortality indicators are missing, due to neither the hospital database nor the social security database having a record of these patientsâ€™ deaths, i.e., they patients are still alive. This is also verified by the aforementioned morality variables, and thus the NA values are converted to FALSE values. The code used for verification is commented out.

```{r}
## Code for verification
# flu_admissions %>%
#   mutate(tt_death = date_part("day", dod) - date_part("day", dischtime))  %>% 
#   mutate(verification = !is.na(tt_death)) ->c
# (all(c$verification == c$mortality_general))

flu_admissions %>%
  mutate(tt_death = date_part("day", dod) - date_part("day", dischtime)) %>%
  mutate(mortality_30 = ifelse(is.na(tt_death)||tt_death>30, F, T) ) %>%
  mutate(age = date_part("year", admittime) - date_part("year", dob)) %>%
  filter(age < 90) %>%
  mutate(age = age - ifelse(
    date_part("month", admittime) < date_part("month", dob) |
      (
        date_part("month", admittime) == date_part("month", dob) &
          date_part("day", admittime) < date_part("day", dob)
      ),
    1,
    0
  )) %>%
  select(-admittime, -dischtime, -dob, -dod, -tt_death) %>%
  select(subject_id, hadm_id, age, mortality_general,
         mortality_in_hospital, mortality_30, everything()) %>%
  print() -> flu_admissions
```

CONSORT Flow Diagrams are generated for the flow of data preparation.

```{r}
library(shape)
library(diagram)

# set margins and multiplot
par(mfrow = c(1, 1))
par(mar = c(0, 0, 0, 0))

# initialise a plot device
openplotmat()

# position of boxes
num_of_boxes <- 5
auto_coords = coordinates(num_of_boxes)
vert_pos = rev(auto_coords[,1])
box_pos <- matrix(nrow = num_of_boxes, ncol = 2, data = 0)
box_pos[1,] = c(0.20, vert_pos[1]) # 1st box
box_pos[2,] = c(0.70, vert_pos[1]) # 2nd box
box_pos[3,] = c(0.70, vert_pos[2]-.05)
box_pos[4,] = c(0.20, vert_pos[3]-.1) # 3rd box
box_pos[5,] = c(0.20, vert_pos[4]-.2) # etc...


# content of boxes
box_content <- matrix(nrow = num_of_boxes, ncol = 1, data = 0)
box_content[1] = "All patients in MIMIC-III \n n = 58,976" # 1st box
box_content[2] = "All diagnosis in MIMIC-III \n n = 14567" # 2nd box
box_content[3] = "Filter diagnosis of influenza \n n = 183" # 3rd box
box_content[4] = "Filter influenza patients \n n = 85" # etc...
box_content[5] = "Detail patients' information \n n = 85"

# adjust the size of boxes to fit content
box_x <- c(0.20, 0.20, 0.20, 0.20, 0.20)
box_y <- c(0.07, 0.07, 0.07, 0.07, 0.07)
# Draw the arrows
straightarrow(from = box_pos[2,], to = box_pos[3,], lwd = 1)
straightarrow(from = box_pos[3,], to = c(0.20, box_pos[3,2]), lwd = 1)
straightarrow(from = box_pos[1,], to = box_pos[4,], lwd = 1)
straightarrow(from = box_pos[4,], to = box_pos[5,], lwd = 1)

# Draw the boxes
for (i in 1:num_of_boxes) {
  textrect(mid = box_pos[i,], radx = box_x[i], rady = box_y[i], 
           lab = box_content[i], 
           shadow.col = "grey")
  }
```
